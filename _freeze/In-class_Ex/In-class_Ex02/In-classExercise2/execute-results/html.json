{
  "hash": "41845df4f2f7432aad273d617aee07a5",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat: \n  html:\n    theme: lux\n    number-sections: true\n\ntitle: \"In-class Exercise 2\"\nauthor: \"Tai Yu Ying\"\ndate: \"Sep 2 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n## Installing and Loading the R packages\n\nIn this hands-on exercise, five R packages will be used, they are:\n\n-   [**sf**](https://r-spatial.github.io/sf/), a relatively new R package specially designed to import, manage and process vector-based geospatial data in R.\n\n-   [**spatstat**](https://spatstat.org/), which has a wide range of useful functions for point pattern analysis. In this hands-on exercise, it will be used to perform 1st- and 2nd-order spatial point patterns analysis and derive kernel density estimation (KDE) layer.\n\n-   [**raster**](https://cran.r-project.org/web/packages/raster/) which reads, writes, manipulates, analyses and model of gridded spatial data (i.e. raster). In this hands-on exercise, it will be used to convert image output generate by spatstat into raster format.\n\n-   [**maptools**](https://cran.r-project.org/web/packages/maptools/index.html) which provides a set of tools for manipulating geographic data. In this hands-on exercise, we mainly use it to convert *Spatial* objects into *ppp* format of **spatstat**.\n\n-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html) which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using [leaflet](https://leafletjs.com/) API.\n\nUse the code chunk below to install and launch the five R packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, raster, spatstat, tmap, tidyverse)\n```\n:::\n\n\n## Issue 1: Installing maptools\n\n**maptools** is retired and binary is removed from CRAN. However, we can download from [Posit Public Package Manager](https://packagemanager.posit.co/client/#/repos/cran/setup?snapshot=2023-10-13&distribution=windows&r_environment=ide) snapshots by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"maptools\", \n                 repos = \"https://packagemanager.posit.co/cran/2023-10-13\")\n```\n:::\n\n\nAfter the installation is completed, it is important to edit the code chunk as shown below in order to avoid **maptools** being download and install repetitively every time the Quarto document been rendered.\n\n![](images/installing%20maptools.png)\n\n## Issue 2: Creating coastal outline\n\nIn **sf** package, there are two functions allow us to combine multiple simple features into one simple features. They are [`st_combine()`](https://r-spatial.github.io/sf/reference/geos_combine.html) and `st_union()`.\n\n-   `st_combine()` returns a single, combined geometry, with no resolved boundaries; returned geometries may well be invalid.\n\n-   If y is missing, `st_union(x)` returns a single geometry with resolved boundaries, else the geometries for all unioned pairs of x\\[i\\] and y\\[j\\].\n\n### Importing the spatial data\n\nIn this section, [*st_read()*](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package will be used to import these three geospatial data sets into R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchildcare_sf <- st_read(\"C:/gniyuy/ISSS626_GA/Hands-on_Ex/Hands-on_Ex02/Data/child-care-services-geojson.geojson\") %>%\n  st_transform(crs = 3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `child-care-services-geojson' from data source \n  `C:\\gniyuy\\ISSS626_GA\\Hands-on_Ex\\Hands-on_Ex02\\Data\\child-care-services-geojson.geojson' \n  using driver `GeoJSON'\nSimple feature collection with 1545 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsg_sf <- st_read(dsn = \"C:/gniyuy/ISSS626_GA/Hands-on_Ex/Hands-on_Ex02/Data/\", layer=\"CostalOutline\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `CostalOutline' from data source \n  `C:\\gniyuy\\ISSS626_GA\\Hands-on_Ex\\Hands-on_Ex02\\Data' using driver `ESRI Shapefile'\nSimple feature collection with 60 features and 4 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2663.926 ymin: 16357.98 xmax: 56047.79 ymax: 50244.03\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf <- st_read(dsn = \"C:/gniyuy/ISSS626_GA/Hands-on_Ex/Hands-on_Ex02/Data/\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\gniyuy\\ISSS626_GA\\Hands-on_Ex\\Hands-on_Ex02\\Data' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n\n### Working with `st_union()`\n\nThe code chunk below, `st_union()`is used to derive the coastal outline sf tibble data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsg_sf <- mpsz_sf %>%\n  st_union()\n```\n:::\n\n\n*sg_sf* will look similar to the figure below.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](In-classExercise2_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n## Introducing spatstat package\n\n[**spatstat**](https://spatstat.org/) R package is a comprehensive open-source toolbox for analysing Spatial Point Patterns. Focused mainly on two-dimensional point patterns, including multitype or marked points, in any spatial region.\n\n## spatstat\n\n### spatstat sub-packages\n\n-   The [**spatstat**](https://cran.r-project.org/web/packages/spatstat/index.html) package now contains only documentation and introductory material. It provides beginner’s introductions, vignettes, interactive demonstration scripts, and a few help files summarising the package.\n\n-   The [**spatstat.data**](https://isss626-ay2024-25aug.netlify.app/in-class_ex/in-class_ex02/in-class_ex02-sppa) package now contains all the datasets for spatstat.\n\n-   The [**spatstat.utils**](https://cran.r-project.org/web/packages/spatstat.utils/index.html) package contains basic utility functions for spatstat.\n\n-   The [**spatstat.univar**](https://cran.r-project.org/web/packages/spatstat.univar/spatstat.univar.pdf) package contains functions for estimating and manipulating probability distributions of one-dimensional random variables.\n\n-   The [**spatstat.sparse**](https://cran.r-project.org/web/packages/spatstat.sparse/spatstat.sparse.pdf) package contains functions for manipulating sparse arrays and performing linear algebra.\n\n-   The [**spatstat.geom**](https://cran.r-project.org/web/packages/spatstat.geom/index.html) package contains definitions of spatial objects (such as point patterns, windows and pixel images) and code which performs geometrical operations.\n\n-   The [**spatstat.random**](https://cran.r-project.org/web/packages/spatstat.random/index.html) package contains functions for random generation of spatial patterns and random simulation of models.\n\n-   The [**spatstat.explore**](https://cran.r-project.org/web/packages/spatstat.explore/index.html) package contains the code for exploratory data analysis and nonparametric analysis of spatial data.\n\n-   The [**spatstat.model**](https://cran.r-project.org/web/packages/spatstat.model/index.html) package contains the code for model-fitting, model diagnostics, and formal inference.\n\n-   The [**spatstat.linnet**](https://cran.r-project.org/web/packages/spatstat.linnet/index.html) package defines spatial data on a linear network, and performs geometrical operations and statistical analysis on such data.\n\n## Creating ppp objects from sf data.frame\n\nInstead of using the two steps approaches discussed in Hands-on Exercise 3 to create the **ppp** objects, in this section you will learn how to work with sf data.frame.\n\n::: panel-tabset\n### `as.ppp()`\n\nIn the code chunk below, [`as.ppp()`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/as.ppp.html) of [**spatstat.geom**](https://cran.r-project.org/web/packages/spatstat.geom/spatstat.geom.pdf) package is used to derive an **ppp** object layer directly from a sf tibble data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchildcare_ppp <- as.ppp(childcare_sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in as.ppp.sf(childcare_sf): only first attribute column is used for\nmarks\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(childcare_ppp)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Only 10 out of 1545 symbols are shown in the symbol map\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](In-classExercise2_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n### `summary()`\n\nNext, `summary()` can be used to reveal the properties of the newly created ppp objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(childcare_ppp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMarked planar point pattern:  1545 points\nAverage intensity 1.91145e-06 points per square unit\n\nCoordinates are given to 11 decimal places\n\nmarks are of type 'character'\nSummary:\n   Length     Class      Mode \n     1545 character character \n\nWindow: rectangle = [11203.01, 45404.24] x [25667.6, 49300.88] units\n                    (34200 x 23630 units)\nWindow area = 808287000 square units\n```\n\n\n:::\n:::\n\n:::\n\n## Creating *owin* object from sf data.frame\n\n::: panel-tabset\n### `as.owin()`\n\nIn the code chunk `as.owin()` of **spatstat.geom** is used to create an **owin** object class from polygon sf tibble data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsg_owin <- as.owin(sg_sf)\nplot(sg_owin)\n```\n\n::: {.cell-output-display}\n![](In-classExercise2_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n### `summary()`\n\nNext, *summary()* function is used to display the summary information of the owin object class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(sg_owin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWindow: polygonal boundary\n50 separate polygons (1 hole)\n                 vertices         area relative.area\npolygon 1 (hole)       30     -7081.18     -9.76e-06\npolygon 2              55     82537.90      1.14e-04\npolygon 3              90    415092.00      5.72e-04\npolygon 4              49     16698.60      2.30e-05\npolygon 5              38     24249.20      3.34e-05\npolygon 6             976  23344700.00      3.22e-02\npolygon 7             721   1927950.00      2.66e-03\npolygon 8            1992   9992170.00      1.38e-02\npolygon 9             330   1118960.00      1.54e-03\npolygon 10            175    925904.00      1.28e-03\npolygon 11            115    928394.00      1.28e-03\npolygon 12             24      6352.39      8.76e-06\npolygon 13            190    202489.00      2.79e-04\npolygon 14             37     10170.50      1.40e-05\npolygon 15             25     16622.70      2.29e-05\npolygon 16             10      2145.07      2.96e-06\npolygon 17             66     16184.10      2.23e-05\npolygon 18           5195 636837000.00      8.78e-01\npolygon 19             76    312332.00      4.31e-04\npolygon 20            627  31891300.00      4.40e-02\npolygon 21             20     32842.00      4.53e-05\npolygon 22             42     55831.70      7.70e-05\npolygon 23             67   1313540.00      1.81e-03\npolygon 24            734   4690930.00      6.47e-03\npolygon 25             16      3194.60      4.40e-06\npolygon 26             15      4872.96      6.72e-06\npolygon 27             15      4464.20      6.15e-06\npolygon 28             14      5466.74      7.54e-06\npolygon 29             37      5261.94      7.25e-06\npolygon 30            111    662927.00      9.14e-04\npolygon 31             69     56313.40      7.76e-05\npolygon 32            143    145139.00      2.00e-04\npolygon 33            397   2488210.00      3.43e-03\npolygon 34             90    115991.00      1.60e-04\npolygon 35             98     62682.90      8.64e-05\npolygon 36            165    338736.00      4.67e-04\npolygon 37            130     94046.50      1.30e-04\npolygon 38             93    430642.00      5.94e-04\npolygon 39             16      2010.46      2.77e-06\npolygon 40            415   3253840.00      4.49e-03\npolygon 41             30     10838.20      1.49e-05\npolygon 42             53     34400.30      4.74e-05\npolygon 43             26      8347.58      1.15e-05\npolygon 44             74     58223.40      8.03e-05\npolygon 45            327   2169210.00      2.99e-03\npolygon 46            177    467446.00      6.44e-04\npolygon 47             46    699702.00      9.65e-04\npolygon 48              6     16841.00      2.32e-05\npolygon 49             13     70087.30      9.66e-05\npolygon 50              4      9459.63      1.30e-05\nenclosing rectangle: [2663.93, 56047.79] x [16357.98, 50244.03] units\n                     (53380 x 33890 units)\nWindow area = 725376000 square units\nFraction of frame area: 0.401\n```\n\n\n:::\n:::\n\n:::\n\n## Combining point events object and owin object\n\n::: panel-tabset\n### `The task`\n\nUsing the step you learned from Hands-on Exercise 3, create an ppp object by combining childcare_ppp and sg_owin.\n\n### `The code`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchildcareSG_ppp = childcare_ppp[sg_owin]\n```\n:::\n\n\n### `The output`\n\nThe output object combined both the point and polygon feature in one ppp object class as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(childcareSG_ppp)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Only 10 out of 1545 symbols are shown in the symbol map\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](In-classExercise2_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n:::\n\n## Kernel Density Estimation of Spatial Point Event\n\nThe code chunk below re-scale the unit of measurement from metre to kilometre before performing KDE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchildcareSG_ppp.km <- rescale.ppp(childcareSG_ppp, \n                                  1000, \n                                  \"km\")\n\nkde_childcareSG_adaptive <- adaptive.density(\n  childcareSG_ppp.km, \n  method=\"kernel\")\nplot(kde_childcareSG_adaptive)\n```\n\n::: {.cell-output-display}\n![](In-classExercise2_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n## Kernel Density Estimation\n\nCode chunk shown two different ways to convert KDE output into grid object.\n\n::: panel-tabset\n### maptools method\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(bg = '#E4D5C9')\n\ngridded_kde_childcareSG_ad <- maptools::as.SpatialGridDataFrame.im(\n  kde_childcareSG_adaptive)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPlease note that 'maptools' will be retired during October 2023,\nplan transition at your earliest convenience (see\nhttps://r-spatial.org/r/2023/05/15/evolution4.html and earlier blogs\nfor guidance);some functionality will be moved to 'sp'.\n Checking rgeos availability: FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nspplot(gridded_kde_childcareSG_ad)\n```\n\n::: {.cell-output-display}\n![](In-classExercise2_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n### spatstat.geom method\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngridded_kde_childcareSG_ad <- as(\n  kde_childcareSG_adaptive,\n  \"SpatialGridDataFrame\")\nspplot(gridded_kde_childcareSG_ad)\n```\n\n::: {.cell-output-display}\n![](In-classExercise2_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n:::\n\n### Rescalling KDE values\n\nIn the code chunk below, *rescale.ppp()* is used to covert the unit of measurement from meter to kilometer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchildcareSG_ppp.km <- rescale.ppp(childcareSG_ppp, 1000, \"km\")\n```\n:::\n\n\nNow, we can re-run *density()* using the resale data set and plot the output kde map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel=\"gaussian\")\nplot(kde_childcareSG.bw)\n```\n\n::: {.cell-output-display}\n![](In-classExercise2_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n### Converting gridded output into raster\n\nNext, we will convert the gridded kernal density objects into RasterLayer object by using *raster()* of **raster** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkde_childcareSG_bw_raster <- raster(kde_childcareSG.bw)\n```\n:::\n\n\n### Visualising KDE using tmap\n\nThe code chunk below is used to plot the output raster by using tmap functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(kde_childcareSG_bw_raster) + \n  tm_raster(palette = \"viridis\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\"), \n            frame = FALSE,\n            bg.color = \"#E4D5C9\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Currect projection of shape kde_childcareSG_bw_raster unknown. Long\nlat (epsg 4326) coordinates assumed.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](In-classExercise2_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n## Extracting study area using sf objects\n\n::: panel-tabset\n### The task\n\nExtract and create an ppp object showing child care services and within Punggol Planning Area\n\n### The code\n\nOn the other hand, `filter()` of dplyr package should be used to extract the target planning areas as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npg_owin <- mpsz_sf %>%\n  filter(PLN_AREA_N == \"PUNGGOL\") %>%\n  as.owin()\n\nchildcare_pg = childcare_ppp[pg_owin]\n\nplot(childcare_pg)  \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in default.charmap(ntypes, chars): Too many types to display every type\nas a different character\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Only 10 out of 61 symbols are shown in the symbol map\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](In-classExercise2_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n:::\n\n## Monte Carlo Simulation\n\n::: tip\nIn order to ensure reproducibility, it is important to include the code chunk below before using `spatstat` functions involving Monte Carlo simulation.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\n## Edge correction methods of spatstat\n\nIn spatstat, edge correction methods are used to handle biases that arise when estimating spatial statistics near the boundaries of a study region. These corrections are essential for ensuring accurate estimates in spatial point pattern analysis, especially for summary statistics like the K-function, L-function, pair correlation function, etc.\n\nCommon Edge Correction Methods in spatstat\n\n-   “none”: No edge correction is applied. This method assumes that there is no bias at the edges, which may lead to underestimation of statistics near the boundaries.\n\n-   “isotropic”: This method corrects for edge effects by assuming that the point pattern is isotropic (uniform in all directions). It compensates for missing neighbors outside the boundary by adjusting the distances accordingly.\n\n-   “translate” (Translation Correction): This method uses a translation correction, which involves translating the observation window so that every point lies entirely within it. The statistic is then averaged over all possible translations.\n\n-   “Ripley” (Ripley’s Correction): Similar to the isotropic correction but specifically tailored for Ripley’s K-function and related functions. It adjusts the expected number of neighbors for points near the edges based on the shape and size of the observation window.\n\n-   “border”: Border correction reduces bias by only considering points far enough from the boundary so that their neighborhood is fully contained within the window. This can be quite conservative but reduces the influence of edge effects.\n\n## Geospatial Analytics for Social Good: Thailand Road Accident Case Study\n\n### Background\n\n-   [Road traffic injuries](https://www.who.int/news-room/fact-sheets/detail/road-traffic-injuries), WHO.\n\n-   [Road traffic deaths and injuries in Thailand](https://cdn.who.int/media/docs/default-source/thailand/roadsafety/overview-en-final-25-7-19.pdf?sfvrsn=f9d7a862_2)\n\n## The Study Area\n\nThe study area is [Bangkok Metropolitan Region](https://en.wikipedia.org/wiki/Bangkok_Metropolitan_Region).\n\n::: Note\nThe projected coordinate system of Thailand is **WGS 84 / UTM zone 47N** and the EPSG code is [32647](https://epsg.io/32647).\n:::\n\n## The Data\n\nFor the purpose of this exercise, three basic data sets are needed, they are:\n\n-   [Thailand Road Accident \\[2019-2022\\]](https://www.kaggle.com/datasets/thaweewatboy/thailand-road-accident-2019-2022) on Kaggle\n\n-   [Thailand Roads (OpenStreetMap Export)](https://data.humdata.org/dataset/hotosm_tha_roads) on HDX.\n\n-   [Thailand - Subnational Administrative Boundaries](https://data.humdata.org/dataset/cod-ab-tha?) on HDX.\n",
    "supporting": [
      "In-classExercise2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}